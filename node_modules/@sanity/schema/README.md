# Sanity schema

## Terminology

- **`Schema`** A collection of types
- **`Type`** A specification of a data structure. Available through schema lookup.
- **`Member type`** A member type is a type contained by a schema type. For example, an array may specify the allowed item types by defining members types from schema types. A reference may be a reference to a set of other types. A member type is not added to the schema and is not available through schema lookup, but rather exists as a property of the owner type.

## Constraints
<<<<<<< HEAD
### No inheritance
You are almost always better off using composition, rather than inheritance hierarchies

E.g.:
=======

### No inheritance

You are almost always better off using composition, rather than inheritance hierarchies

E.g.:

>>>>>>> origin/main
```js
const PERSON = {
  type: 'object',
  name: 'person',
  fields: [
    {name: 'firstName', type: 'string'},
    {
      name: 'address',
      type: 'object',
      fields: [
        {
          name: 'street',
<<<<<<< HEAD
          type: 'string'
        }
      ]
    }
  ]
=======
          type: 'string',
        },
      ],
    },
  ],
>>>>>>> origin/main
}
```

If one were to introduce a user type, it would be tempting to think of it as a subtype of person, adding a few additional fields specific for the user type, like this:

```js
<<<<<<< HEAD
const USER = { // modelling user as a subtype of person
=======
const USER = {
  // modelling user as a subtype of person
>>>>>>> origin/main
  name: 'user',
  type: 'person',
  fields: [
    {
      name: 'username',
<<<<<<< HEAD
      type: 'string'
    }
  ]
}
```
=======
      type: 'string',
    },
  ],
}
```

>>>>>>> origin/main
A problem with the above is: how do we merge the fields? Should the fields from `PERSON` be placed before the fields from `USER`? What if both types define the same field, should the subtype override? What if that field is an object where we'd like to keep some of the fields, but remove others? It quite quickly becomes messy.

A better solution would be to define common fields outside, and re-use them across types:

e.g.:

```js
<<<<<<< HEAD

=======
>>>>>>> origin/main
const FIRST_NAME_FIELD = {name: 'firstName', type: 'string'}
const ADDRESS_FIELD = {
  name: 'address',
  type: 'object',
  fields: [
    {
      name: 'zip',
<<<<<<< HEAD
      type: 'string'
    },
    {
      name: 'street',
      type: 'string'
    },
    {
      name: 'city',
      type: 'string'
    }
=======
      type: 'string',
    },
    {
      name: 'street',
      type: 'string',
    },
    {
      name: 'city',
      type: 'string',
    },
>>>>>>> origin/main
  ],
}

const PERSON = {
  type: 'object',
  name: 'person',
<<<<<<< HEAD
  fields: [
    FIRST_NAME_FIELD,
    ADDRESS_FIELD
  ]
=======
  fields: [FIRST_NAME_FIELD, ADDRESS_FIELD],
>>>>>>> origin/main
}

const USER = {
  type: 'object',
  name: 'person',
<<<<<<< HEAD
  fields: [
    FIRST_NAME_FIELD,
    {name: 'username', type: 'string'},
    ADDRESS_FIELD
  ]
}
```

You could even take this further by extracting the individual fields of the `address` type and compose in different ways.
=======
  fields: [FIRST_NAME_FIELD, {name: 'username', type: 'string'}, ADDRESS_FIELD],
}
```

You could even take this further by extracting the individual fields of the `address` type and compose in different ways.
>>>>>>> origin/main
