// Converts a string into an abstract syntax tree representation

<<<<<<< HEAD
import tokenize from './tokenize'
import {Expr} from './Expression'
=======
import {tokenize} from './tokenize'
import {
  type AliasExpr,
  type AttributeExpr,
  type BooleanExpr,
  type ConstraintExpr,
  type IndexExpr,
  type NumberExpr,
  type PathExpr,
  type RangeExpr,
  type RecursiveExpr,
  type StringExpr,
  type Token,
  type UnionExpr,
} from './types'
>>>>>>> origin/main

// TODO: Support '*'

class Parser {
<<<<<<< HEAD
  tokens: any[]
  length: number
  i: number
=======
  tokens: Token[]
  length: number
  i: number

>>>>>>> origin/main
  constructor(path: string) {
    this.tokens = tokenize(path)
    this.length = this.tokens.length
    this.i = 0
  }

  parse() {
    return this.parsePath()
  }

  EOF() {
    return this.i >= this.length
  }

  // Look at upcoming token
  peek() {
    if (this.EOF()) {
      return null
    }
    return this.tokens[this.i]
  }

  consume() {
    const result = this.peek()
<<<<<<< HEAD
    // console.log("consumed", result)
=======
>>>>>>> origin/main
    this.i += 1
    return result
  }

  // Return next token if it matches the pattern
<<<<<<< HEAD
  probe(pattern) {
    const token = this.peek()
    // console.log("Probing", token, "for", pattern)
    if (!token) {
      // console.log(" -> nay", token)
      return null
    }
    const mismatch = Object.keys(pattern).find((key) => {
      const value = pattern[key]
      if (!token[key] || token[key] != value) {
        // console.log(" -> nay", key)
        return true
      }
      return false
    })
    if (mismatch) {
      return null
    }
    // console.log(" -> yay", token)
    return token
  }

  // Return and consume next token if it matches the pattern
  match(pattern) {
    if (this.probe(pattern)) {
      return this.consume()
    }
    return null
  }

  parseAttribute(): Object {
    const token = this.match({type: 'identifier'})
    if (token) {
=======
  probe(pattern: Record<string, unknown>): Token | null {
    const token = this.peek()
    if (!token) {
      return null
    }

    const record = token as unknown as Record<string, unknown>
    const match = Object.keys(pattern).every((key) => {
      return key in token && pattern[key] === record[key]
    })

    return match ? token : null
  }

  // Return and consume next token if it matches the pattern
  match(pattern: Partial<Token>): Token | null {
    return this.probe(pattern) ? this.consume() : null
  }

  parseAttribute(): AttributeExpr | null {
    const token = this.match({type: 'identifier'})
    if (token && token.type === 'identifier') {
>>>>>>> origin/main
      return {
        type: 'attribute',
        name: token.name,
      }
    }
    const quoted = this.match({type: 'quoted', quote: 'single'})
<<<<<<< HEAD
    if (quoted) {
      return {
        type: 'attribute',
        name: quoted.value,
=======
    if (quoted && quoted.type === 'quoted') {
      return {
        type: 'attribute',
        name: quoted.value || '',
>>>>>>> origin/main
      }
    }
    return null
  }

<<<<<<< HEAD
  parseAlias(): Object {
=======
  parseAlias(): AliasExpr | null {
>>>>>>> origin/main
    if (this.match({type: 'keyword', symbol: '@'}) || this.match({type: 'keyword', symbol: '$'})) {
      return {
        type: 'alias',
        target: 'self',
      }
    }
    return null
  }

<<<<<<< HEAD
  parseNumber(): Expr {
    const token = this.match({type: 'number'})
    if (token) {
=======
  parseNumber(): NumberExpr | null {
    const token = this.match({type: 'number'})
    if (token && token.type === 'number') {
>>>>>>> origin/main
      return {
        type: 'number',
        value: token.value,
      }
    }
    return null
  }

<<<<<<< HEAD
  parseNumberValue(): Object {
=======
  parseNumberValue(): number | null {
>>>>>>> origin/main
    const expr = this.parseNumber()
    if (expr) {
      return expr.value
    }
    return null
  }

<<<<<<< HEAD
  parseSliceSelector() {
    const start = this.i
    const result: any = {
      type: 'range',
    }
    result.start = this.parseNumberValue()
    const colon1 = this.match({type: 'operator', symbol: ':'})
    if (colon1) {
      result.end = this.parseNumberValue()
      const colon2 = this.match({type: 'operator', symbol: ':'})
      if (colon2) {
        result.step = this.parseNumberValue()
      }
    } else {
      if (result.start !== null) {
        // Unwrap, this was just a single index not followed by colon
        return {type: 'index', value: result.start}
      }
      // Rewind, this was actually nothing
      this.i = start
      return null
    }
    if (result.start === null && result.end === null) {
      // rewind, this wasnt' a slice selector
      this.i = start
      // console.log("Mising start and end of slice, rewinding")
      return null
    }
    return result
  }

  parseValueReference(): Object {
    return this.parseAttribute() || this.parseSliceSelector()
  }

  parseLiteralValue(): Object {
    const literalString = this.match({type: 'quoted', quote: 'double'})
    if (literalString) {
      return {
        type: 'string',
        value: literalString.value,
      }
    }
    const literalBoolean = this.match({type: 'boolean'})
    if (literalBoolean) {
      return {
        type: 'boolean',
        value: literalBoolean.symbol == 'true',
=======
  parseSliceSelector(): RangeExpr | IndexExpr | null {
    const start = this.i
    const rangeStart = this.parseNumberValue()

    const colon1 = this.match({type: 'operator', symbol: ':'})
    if (!colon1) {
      if (rangeStart === null) {
        // Rewind, this was actually nothing
        this.i = start
        return null
      }

      // Unwrap, this was just a single index not followed by colon
      return {type: 'index', value: rangeStart}
    }

    const result: RangeExpr = {
      type: 'range',
      start: rangeStart,
      end: this.parseNumberValue(),
    }

    const colon2 = this.match({type: 'operator', symbol: ':'})
    if (colon2) {
      result.step = this.parseNumberValue()
    }

    if (result.start === null && result.end === null) {
      // rewind, this wasnt' a slice selector
      this.i = start
      return null
    }

    return result
  }

  parseValueReference(): AttributeExpr | RangeExpr | IndexExpr | null {
    return this.parseAttribute() || this.parseSliceSelector()
  }

  parseLiteralValue(): StringExpr | BooleanExpr | NumberExpr | null {
    const literalString = this.match({type: 'quoted', quote: 'double'})
    if (literalString && literalString.type === 'quoted') {
      return {
        type: 'string',
        value: literalString.value || '',
      }
    }
    const literalBoolean = this.match({type: 'boolean'})
    if (literalBoolean && literalBoolean.type === 'boolean') {
      return {
        type: 'boolean',
        value: literalBoolean.symbol === 'true',
>>>>>>> origin/main
      }
    }
    return this.parseNumber()
  }

  // TODO: Reorder constraints so that literal value is always on rhs, and variable is always
  // on lhs.
<<<<<<< HEAD
  parseFilterExpression(): Object {
=======
  parseFilterExpression(): ConstraintExpr | null {
>>>>>>> origin/main
    const start = this.i
    const expr = this.parseAttribute() || this.parseAlias()
    if (!expr) {
      return null
    }
<<<<<<< HEAD
=======

>>>>>>> origin/main
    if (this.match({type: 'operator', symbol: '?'})) {
      return {
        type: 'constraint',
        operator: '?',
        lhs: expr,
      }
    }
<<<<<<< HEAD
    const binOp = this.match({type: 'comparator'})
    if (!binOp) {
=======

    const binOp = this.match({type: 'comparator'})
    if (!binOp || binOp.type !== 'comparator') {
>>>>>>> origin/main
      // No expression, rewind!
      this.i = start
      return null
    }
<<<<<<< HEAD
=======

>>>>>>> origin/main
    const lhs = expr
    const rhs = this.parseLiteralValue()
    if (!rhs) {
      throw new Error(`Operator ${binOp.symbol} needs a literal value at the right hand side`)
    }
<<<<<<< HEAD
=======

>>>>>>> origin/main
    return {
      type: 'constraint',
      operator: binOp.symbol,
      lhs: lhs,
      rhs: rhs,
    }
  }

<<<<<<< HEAD
  parseExpression(): Object {
    return this.parseFilterExpression() || this.parseValueReference()
  }

  parseUnion(): Object {
    if (!this.match({type: 'paren', symbol: '['})) {
      return null
    }
=======
  parseExpression(): ConstraintExpr | AttributeExpr | RangeExpr | IndexExpr | null {
    return this.parseFilterExpression() || this.parseValueReference()
  }

  parseUnion(): UnionExpr | null {
    if (!this.match({type: 'paren', symbol: '['})) {
      return null
    }

>>>>>>> origin/main
    const terms = []
    let expr = this.parseFilterExpression() || this.parsePath() || this.parseValueReference()
    while (expr) {
      terms.push(expr)
      // End of union?
      if (this.match({type: 'paren', symbol: ']'})) {
        break
      }
<<<<<<< HEAD
      if (!this.match({type: 'operator', symbol: ','})) {
        throw new Error('Expected ]')
      }
=======

      if (!this.match({type: 'operator', symbol: ','})) {
        throw new Error('Expected ]')
      }

>>>>>>> origin/main
      expr = this.parseFilterExpression() || this.parsePath() || this.parseValueReference()
      if (!expr) {
        throw new Error("Expected expression following ','")
      }
    }
<<<<<<< HEAD
    // console.log("Union terms", terms)
    // return unionFromTerms(terms)
=======

>>>>>>> origin/main
    return {
      type: 'union',
      nodes: terms,
    }
  }

<<<<<<< HEAD
  parseRecursive(): Object {
    if (this.match({type: 'operator', symbol: '..'})) {
      const subpath = this.parsePath()
      if (!subpath) {
        throw new Error("Expected path following '..' operator")
      }
      return {
        type: 'recursive',
        term: subpath,
      }
    }
    return null
  }

  parsePath(): Object {
    const nodes = []
=======
  parseRecursive(): RecursiveExpr | null {
    if (!this.match({type: 'operator', symbol: '..'})) {
      return null
    }

    const subpath = this.parsePath()
    if (!subpath) {
      throw new Error("Expected path following '..' operator")
    }

    return {
      type: 'recursive',
      term: subpath,
    }
  }

  parsePath(): PathExpr | AttributeExpr | UnionExpr | RecursiveExpr | null {
    const nodes: (AttributeExpr | UnionExpr | RecursiveExpr)[] = []
>>>>>>> origin/main
    const expr = this.parseAttribute() || this.parseUnion() || this.parseRecursive()
    if (!expr) {
      return null
    }
<<<<<<< HEAD
=======

>>>>>>> origin/main
    nodes.push(expr)
    while (!this.EOF()) {
      if (this.match({type: 'operator', symbol: '.'})) {
        const attr = this.parseAttribute()
        if (!attr) {
          throw new Error("Expected attribute name following '.")
        }
        nodes.push(attr)
        continue
      } else if (this.probe({type: 'paren', symbol: '['})) {
        const union = this.parseUnion()
        if (!union) {
          throw new Error("Expected union following '['")
        }
        nodes.push(union)
      } else {
        const recursive = this.parseRecursive()
        if (recursive) {
          nodes.push(recursive)
        }
        break
      }
    }
<<<<<<< HEAD
    if (nodes.length == 1) {
      return nodes[0]
    }
=======

    if (nodes.length === 1) {
      return nodes[0]
    }

>>>>>>> origin/main
    return {
      type: 'path',
      nodes: nodes,
    }
  }
}

<<<<<<< HEAD
export default function parse(path: string): any {
  return new Parser(path).parse()
}

// Todo: find out if these has any value (currently not in used)
// function unionFromTerms(terms): any {
//   let result: any = {
//     type: 'union'
//   }
//   terms.forEach(term => {
//     switch (term.type) {
//       case 'index':
//         result.indexes = (result.indexes || []).concat(term.value)
//         break
//       case 'range':
//         result.ranges = (result.ranges || []).concat(term)
//         break
//       case 'path':
//         result.paths = (result.paths || []).concat(term)
//         break
//       case 'constraint':
//         result.constraints = (result.constraints || []).concat(term)
//         break
//       case 'union':
//         result = mergeUnions(result, term)
//         break
//       default:
//         throw new Error(`Unexpected union member of type ${term.type}`)
//     }
//   })
//   if (result.indexes) {
//     result.indexes = uniq(result.indexes)
//   }
//   return result
// }
// function mergeUnions(union1, union2): Object {
//   const result = {
//     type: 'union'
//   }
//   uniq(Object.keys(union1).concat(Object.keys(union2))).forEach(key => {
//     result[key] = (union1[key] || []).concat(union2[key] || [])
//   })
//   return result
// }
=======
export function parseJsonPath(path: string): PathExpr | AttributeExpr | UnionExpr | RecursiveExpr {
  const parsed = new Parser(path).parse()
  if (!parsed) {
    throw new Error(`Failed to parse JSON path "${path}"`)
  }
  return parsed
}
>>>>>>> origin/main
