<<<<<<< HEAD
import parse from './parse'
import Descender, {Probe} from './Descender'
import Expression from './Expression'

type Result = {
  leads: any[]
  delivery?: any
}
export default class Matcher {
  active: Array<Descender>
  recursives: Array<Descender>
  payload: any
  constructor(active: Array<Descender>, parent?: Matcher) {
=======
import {Descender} from './Descender'
import {Expression} from './Expression'
import {parseJsonPath} from './parse'
import {type Probe} from './Probe'

interface Result<P = unknown> {
  leads: {
    target: Expression
    matcher: Matcher
  }[]

  delivery?: {
    targets: Expression[]
    payload: P
  }
}

/**
 * @internal
 */
export class Matcher {
  active: Descender[]
  recursives: Descender[]
  payload: unknown

  constructor(active: Descender[], parent?: Matcher) {
>>>>>>> origin/main
    this.active = active || []
    if (parent) {
      this.recursives = parent.recursives
      this.payload = parent.payload
    } else {
      this.recursives = []
    }
    this.extractRecursives()
  }

<<<<<<< HEAD
  setPayload(payload: any) {
=======
  setPayload(payload: unknown): this {
>>>>>>> origin/main
    this.payload = payload
    return this
  }

  // Moves any recursive descenders onto the recursive track, removing them from
  // the active set
<<<<<<< HEAD
  extractRecursives() {
    // console.log(JSON.stringify(this.active))
=======
  extractRecursives(): void {
>>>>>>> origin/main
    this.active = this.active.filter((descender) => {
      if (descender.isRecursive()) {
        this.recursives.push(...descender.extractRecursives())
        return false
      }
      return true
    })
  }

  // Find recursives that are relevant now and should be considered part of the active set
<<<<<<< HEAD
  activeRecursives(probe: Probe): Array<Descender> {
    return this.recursives.filter((descender) => {
      const head = descender.head
=======
  activeRecursives(probe: Probe): Descender[] {
    return this.recursives.filter((descender) => {
      const head = descender.head
      if (!head) {
        return false
      }

>>>>>>> origin/main
      // Constraints are always relevant
      if (head.isConstraint()) {
        return true
      }
<<<<<<< HEAD
      // Index references are only relevant for indexable values
      if (probe.containerType() == 'array' && head.isIndexReference()) {
        return true
      }
      // Attribute references are relevant for plain objects
      if (probe.containerType() == 'object') {
        if (head.isAttributeReference() && probe.hasAttribute(head.name())) {
          return true
        }
      }
=======

      // Index references are only relevant for indexable values
      if (probe.containerType() === 'array' && head.isIndexReference()) {
        return true
      }

      // Attribute references are relevant for plain objects
      if (probe.containerType() === 'object') {
        return head.isAttributeReference() && probe.hasAttribute(head.name())
      }

>>>>>>> origin/main
      return false
    })
  }

<<<<<<< HEAD
  match(probe: Probe): Object {
=======
  match(probe: Probe): Result {
>>>>>>> origin/main
    return this.iterate(probe).extractMatches(probe)
  }

  iterate(probe: Probe): Matcher {
<<<<<<< HEAD
    const newActiveSet: Array<Descender> = []
=======
    const newActiveSet: Descender[] = []
>>>>>>> origin/main
    this.active.concat(this.activeRecursives(probe)).forEach((descender) => {
      newActiveSet.push(...descender.iterate(probe))
    })
    return new Matcher(newActiveSet, this)
  }

  // Returns true if any of the descenders in the active or recursive set
  // consider the current state a final destination
  isDestination(): boolean {
<<<<<<< HEAD
    const arrival = this.active.find((descender) => {
      if (descender.hasArrived()) {
        return true
      }
      return false
    })
    return !!arrival
=======
    return this.active.some((descender) => descender.hasArrived())
>>>>>>> origin/main
  }

  hasRecursives(): boolean {
    return this.recursives.length > 0
  }

  // Returns any payload delivieries and leads that needs to be followed to complete
  // the process.
  extractMatches(probe: Probe): Result {
<<<<<<< HEAD
    const leads = []
    const targets = []
    this.active.forEach((descender) => {
      if (descender.hasArrived()) {
        // This was allready arrived, so matches this value, not descenders
=======
    const leads: {target: Expression; matcher: Matcher}[] = []
    const targets: Expression[] = []
    this.active.forEach((descender) => {
      if (descender.hasArrived()) {
        // This was already arrived, so matches this value, not descenders
>>>>>>> origin/main
        targets.push(
          new Expression({
            type: 'alias',
            target: 'self',
<<<<<<< HEAD
          })
        )
        return
      }
      if (probe.containerType() == 'array' && !descender.head.isIndexReference()) {
        // This descender does not match an indexable value
        return
      }
      if (probe.containerType() == 'object' && !descender.head.isAttributeReference()) {
        // This descender never match a plain object
        return
      }
      // const newDescenders = descender.descend()
      // console.log('newDescenders', newDescenders)
      if (descender.tail) {
        // Not arrived yet
        const matcher = new Matcher(descender.descend(), this)
        descender.head.toFieldReferences().forEach((field) => {
          leads.push({
            target: descender.head,
=======
          }),
        )
        return
      }

      const descenderHead = descender.head
      if (!descenderHead) {
        return
      }

      if (probe.containerType() === 'array' && !descenderHead.isIndexReference()) {
        // This descender does not match an indexable value
        return
      }

      if (probe.containerType() === 'object' && !descenderHead.isAttributeReference()) {
        // This descender never match a plain object
        return
      }

      if (descender.tail) {
        // Not arrived yet
        const matcher = new Matcher(descender.descend(), this)
        descenderHead.toFieldReferences().forEach(() => {
          leads.push({
            target: descenderHead,
>>>>>>> origin/main
            matcher: matcher,
          })
        })
      } else {
        // arrived
<<<<<<< HEAD
        targets.push(descender.head)
=======
        targets.push(descenderHead)
>>>>>>> origin/main
      }
    })

    // If there are recursive terms, we need to add a lead for every descendant ...
    if (this.hasRecursives()) {
      // The recustives matcher will have no active set, only inherit recursives from this
      const recursivesMatcher = new Matcher([], this)
<<<<<<< HEAD
      if (probe.containerType() == 'array') {
=======
      if (probe.containerType() === 'array') {
>>>>>>> origin/main
        const length = probe.length()
        for (let i = 0; i < length; i++) {
          leads.push({
            target: Expression.indexReference(i),
            matcher: recursivesMatcher,
          })
        }
<<<<<<< HEAD
      } else if (probe.containerType() == 'object') {
=======
      } else if (probe.containerType() === 'object') {
>>>>>>> origin/main
        probe.attributeKeys().forEach((name) => {
          leads.push({
            target: Expression.attributeReference(name),
            matcher: recursivesMatcher,
          })
        })
      }
    }

<<<<<<< HEAD
    const result: Result = {
      leads: leads,
    }
    if (targets.length > 0) {
      result.delivery = {
        targets: targets,
        payload: this.payload,
      }
    }
    return result
  }

  static fromPath(jsonpath: string) {
    const descender = new Descender(null, new Expression(parse(jsonpath)))
=======
    return targets.length > 0
      ? {leads: leads, delivery: {targets, payload: this.payload}}
      : {leads: leads}
  }

  static fromPath(jsonpath: string): Matcher {
    const path = parseJsonPath(jsonpath)
    if (!path) {
      throw new Error(`Failed to parse path from "${jsonpath}"`)
    }

    const descender = new Descender(null, new Expression(path))
>>>>>>> origin/main
    return new Matcher(descender.descend())
  }
}
