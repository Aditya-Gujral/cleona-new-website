import {compact} from 'lodash'
<<<<<<< HEAD
import {Expression, Matcher} from '../jsonpath'
import PlainProbe from './PlainProbe'

export default function extract(path: string, value: Object): Array<any> {
  const result = []
  const appendResult = (values) => {
    result.push(...values)
  }
  const matcher = Matcher.fromPath(path).setPayload(appendResult)
=======

import {type Expression} from './Expression'
import {Matcher} from './Matcher'
import {PlainProbe} from './PlainProbe'
import {type Probe} from './Probe'

export function extractAccessors(path: string, value: unknown): Probe[] {
  const result: Probe[] = []
  const matcher = Matcher.fromPath(path).setPayload(function appendResult(values: Probe[]) {
    result.push(...values)
  })
>>>>>>> origin/main
  const accessor = new PlainProbe(value)
  descend(matcher, accessor)
  return result
}

<<<<<<< HEAD
function descend(matcher, accessor) {
  const {leads, delivery} = matcher.match(accessor)
=======
function descend(matcher: Matcher, accessor: Probe) {
  const {leads, delivery} = matcher.match(accessor)

>>>>>>> origin/main
  leads.forEach((lead) => {
    accessorsFromTarget(lead.target, accessor).forEach((childAccessor) => {
      descend(lead.matcher, childAccessor)
    })
  })
<<<<<<< HEAD
  if (delivery) {
    delivery.targets.forEach((target) => {
      delivery.payload(accessorsFromTarget(target, accessor))
=======

  if (delivery) {
    delivery.targets.forEach((target) => {
      if (typeof delivery.payload === 'function') {
        delivery.payload(accessorsFromTarget(target, accessor))
      }
>>>>>>> origin/main
    })
  }
}

<<<<<<< HEAD
function accessorsFromTarget(target: Expression, accessor: PlainProbe) {
=======
function accessorsFromTarget(target: Expression, accessor: Probe) {
>>>>>>> origin/main
  const result = []
  if (target.isIndexReference()) {
    target.toIndicies(accessor).forEach((i) => {
      result.push(accessor.getIndex(i))
    })
  } else if (target.isAttributeReference()) {
    result.push(accessor.getAttribute(target.name()))
  } else if (target.isSelfReference()) {
    result.push(accessor)
  } else {
    throw new Error(`Unable to derive accessor for target ${target.toString()}`)
  }
  return compact(result)
}
