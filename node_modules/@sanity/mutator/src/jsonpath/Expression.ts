// A utility wrapper class to process parsed jsonpath expressions

<<<<<<< HEAD
import descend from './descend'
import toPath from './toPath'
import parse from './parse'
import {Probe} from './Descender'

export type Expr = any
export type Range = {
=======
import {descend} from './descend'
import {parseJsonPath} from './parse'
import {type Probe} from './Probe'
import {toPath} from './toPath'
import {type Expr, type HeadTail} from './types'

export interface Range {
>>>>>>> origin/main
  start: number
  end: number
  step: number
}

<<<<<<< HEAD
export default class Expression {
  expr: Expr
  constructor(expr: Expr) {
    // This is a wrapped expr
    if (expr.expr) {
=======
export class Expression {
  expr: Expr

  constructor(expr: Expr | Expression | null) {
    if (!expr) {
      throw new Error('Attempted to create Expression from null-value')
    }

    // This is a wrapped expr
    if ('expr' in expr) {
>>>>>>> origin/main
      this.expr = expr.expr
    } else {
      this.expr = expr
    }
<<<<<<< HEAD
    if (!this.expr.type) {
      throw new Error('Attempt to create Expression for expression with no type')
    }
  }
  isPath(): boolean {
    return this.expr.type == 'path'
  }
  isUnion(): boolean {
    return this.expr.type == 'union'
  }
  isCollection(): boolean {
    return this.isPath() || this.isUnion()
  }
  isConstraint(): boolean {
    return this.expr.type == 'constraint'
  }
  isRecursive(): boolean {
    return this.expr.type == 'recursive'
  }
  isExistenceConstraint(): boolean {
    return this.isConstraint() && this.expr.operator == '?'
  }
  isIndex(): boolean {
    return this.expr.type == 'index'
  }
  isRange(): boolean {
    return this.expr.type == 'range'
  }
  expandRange(probe: Probe): Range {
    let start = this.expr.start || 0
    start = interpretNegativeIndex(start, probe)
    let end = this.expr.end || probe.length()
    end = interpretNegativeIndex(end, probe)
    const step = this.expr.step || 1
    return {start, end, step}
  }
  isAttributeReference(): boolean {
    return this.expr.type == 'attribute'
  }
=======

    if (!('type' in this.expr)) {
      throw new Error('Attempt to create Expression for expression with no type')
    }
  }

  isPath(): boolean {
    return this.expr.type === 'path'
  }

  isUnion(): boolean {
    return this.expr.type === 'union'
  }

  isCollection(): boolean {
    return this.isPath() || this.isUnion()
  }

  isConstraint(): boolean {
    return this.expr.type === 'constraint'
  }

  isRecursive(): boolean {
    return this.expr.type === 'recursive'
  }

  isExistenceConstraint(): boolean {
    return this.expr.type === 'constraint' && this.expr.operator === '?'
  }

  isIndex(): boolean {
    return this.expr.type === 'index'
  }

  isRange(): boolean {
    return this.expr.type === 'range'
  }

  expandRange(probe?: Probe): Range {
    const probeLength = () => {
      if (!probe) {
        throw new Error('expandRange() required a probe that was not passed')
      }

      return probe.length()
    }

    let start = 'start' in this.expr ? this.expr.start || 0 : 0
    start = interpretNegativeIndex(start, probe)
    let end = 'end' in this.expr ? this.expr.end || probeLength() : probeLength()
    end = interpretNegativeIndex(end, probe)
    const step = 'step' in this.expr ? this.expr.step || 1 : 1
    return {start, end, step}
  }

  isAttributeReference(): boolean {
    return this.expr.type === 'attribute'
  }

>>>>>>> origin/main
  // Is a range or index -> something referencing indexes
  isIndexReference(): boolean {
    return this.isIndex() || this.isRange()
  }
<<<<<<< HEAD
  name(): string {
    return this.expr.name
  }
  isSelfReference(): boolean {
    return this.expr.type == 'alias' && this.expr.target == 'self'
  }
  constraintTargetIsSelf() {
    return this.isConstraint() && this.expr.lhs.type == 'alias' && this.expr.lhs.target == 'self'
  }
  constraintTargetIsAttribute() {
    return this.isConstraint() && this.expr.lhs.type == 'attribute'
  }
  testConstraint(probe: Probe): boolean {
    if (this.constraintTargetIsSelf()) {
      if (probe.containerType() != 'primitive') {
        return false
      }
      if (this.isExistenceConstraint()) {
        return true
      }
      const lhs = probe.get()
      const rhs = this.expr.rhs.value
      return testBinaryOperator(lhs, this.expr.operator, rhs)
    }
    if (!this.constraintTargetIsAttribute()) {
      throw new Error(`Constraint target ${this.expr.lhs.type} not supported`)
    }
    if (probe.containerType() != 'object') {
      return false
    }
    const lhs = probe.getAttribute(this.expr.lhs.name)
    if (lhs === undefined || lhs === null || lhs.containerType() != 'primitive') {
      // LHS is void and empty, or it is a collection
      return false
    }
=======

  name(): string {
    return 'name' in this.expr ? this.expr.name : ''
  }

  isSelfReference(): boolean {
    return this.expr.type === 'alias' && this.expr.target === 'self'
  }

  constraintTargetIsSelf(): boolean {
    return (
      this.expr.type === 'constraint' &&
      this.expr.lhs.type === 'alias' &&
      this.expr.lhs.target === 'self'
    )
  }

  constraintTargetIsAttribute(): boolean {
    return this.expr.type === 'constraint' && this.expr.lhs.type === 'attribute'
  }

  testConstraint(probe: Probe): boolean {
    const expr = this.expr

    if (expr.type === 'constraint' && expr.lhs.type === 'alias' && expr.lhs.target === 'self') {
      if (probe.containerType() !== 'primitive') {
        return false
      }

      if (expr.type === 'constraint' && expr.operator === '?') {
        return true
      }

      const lhs = probe.get()
      const rhs = expr.rhs && 'value' in expr.rhs ? expr.rhs.value : undefined
      return testBinaryOperator(lhs, expr.operator, rhs)
    }

    if (expr.type !== 'constraint') {
      return false
    }

    const lhs = expr.lhs
    if (!lhs) {
      throw new Error('No LHS of expression')
    }

    if (lhs.type !== 'attribute') {
      throw new Error(`Constraint target ${lhs.type} not supported`)
    }

    if (probe.containerType() !== 'object') {
      return false
    }

    const lhsValue = probe.getAttribute(lhs.name)
    if (lhsValue === undefined || lhsValue === null || lhsValue.containerType() !== 'primitive') {
      // LHS is void and empty, or it is a collection
      return false
    }

>>>>>>> origin/main
    if (this.isExistenceConstraint()) {
      // There is no rhs, and if we're here the key did exist
      return true
    }
<<<<<<< HEAD
    const rhs = this.expr.rhs.value
    return testBinaryOperator(lhs.get(), this.expr.operator, rhs)
  }
  pathNodes() {
    if (this.isPath()) {
      return this.expr.nodes
    }
    return [this.expr]
  }
  prepend(node) {
    if (!node) {
      return this
    }
=======

    const rhs = expr.rhs && 'value' in expr.rhs ? expr.rhs.value : undefined
    return testBinaryOperator(lhsValue.get(), expr.operator, rhs)
  }

  pathNodes(): Expr[] {
    return this.expr.type === 'path' ? this.expr.nodes : [this.expr]
  }

  prepend(node: Expression): Expression {
    if (!node) {
      return this
    }

>>>>>>> origin/main
    return new Expression({
      type: 'path',
      nodes: node.pathNodes().concat(this.pathNodes()),
    })
  }
<<<<<<< HEAD
  concat(other) {
    if (!other) {
      return this
    }
    return other.prepend(this)
  }
  descend() {
=======

  concat(other: Expression | null): Expression {
    return other ? other.prepend(this) : this
  }

  descend(): HeadTail[] {
>>>>>>> origin/main
    return descend(this.expr).map((headTail) => {
      const [head, tail] = headTail
      return {
        head: head ? new Expression(head) : null,
        tail: tail ? new Expression(tail) : null,
      }
    })
  }
<<<<<<< HEAD
  unwrapRecursive() {
    if (!this.isRecursive()) {
      throw new Error(`Attempt to unwrap recursive on type ${this.expr.type}`)
    }
    return new Expression(this.expr.term)
  }
  toIndicies(probe?: Probe): Array<number> {
    if (!this.isIndexReference()) {
      throw new Error('Node cannot be converted to indexes')
    }
    if (this.expr.type == 'index') {
      return [interpretNegativeIndex(this.expr.value, probe)]
    } else if (this.expr.type == 'range') {
      const result: Array<number> = []
      let {start, end, step} = this.expandRange(probe)
      if (step < 0) {
        ;[start, end] = [end, start]
      }
      for (let i = start; i < end; i++) {
        result.push(i)
      }
      return result
    }
    throw new Error(`Unable to convert ${this.expr.type} to indices`)
  }
  toFieldReferences(): Array<any> {
    if (this.isIndexReference()) {
      return this.toIndicies()
    }
    if (this.isAttributeReference()) {
      return [this.name()]
    }
    throw new Error(`Can't convert ${this.expr.type} to field references`)
  }
  toString(): string {
    return toPath(this.expr)
  }
  static fromPath(path: string) {
    return new Expression(parse(path))
  }
  static attributeReference(name: string) {
=======

  unwrapRecursive(): Expression {
    if (this.expr.type !== 'recursive') {
      throw new Error(`Attempt to unwrap recursive on type ${this.expr.type}`)
    }

    return new Expression(this.expr.term)
  }

  toIndicies(probe?: Probe): number[] {
    if (this.expr.type !== 'index' && this.expr.type !== 'range') {
      throw new Error('Node cannot be converted to indexes')
    }

    if (this.expr.type === 'index') {
      return [interpretNegativeIndex(this.expr.value, probe)]
    }

    const result: number[] = []
    const range = this.expandRange(probe)
    let {start, end} = range
    if (range.step < 0) {
      ;[start, end] = [end, start]
    }

    for (let i = start; i < end; i++) {
      result.push(i)
    }

    return result
  }

  toFieldReferences(): number[] | string[] {
    if (this.isIndexReference()) {
      return this.toIndicies()
    }
    if (this.expr.type === 'attribute') {
      return [this.expr.name]
    }
    throw new Error(`Can't convert ${this.expr.type} to field references`)
  }

  toString(): string {
    return toPath(this.expr)
  }

  static fromPath(path: string): Expression {
    const parsed = parseJsonPath(path)
    if (!parsed) {
      throw new Error(`Failed to parse path "${path}"`)
    }

    return new Expression(parsed)
  }

  static attributeReference(name: string): Expression {
>>>>>>> origin/main
    return new Expression({
      type: 'attribute',
      name: name,
    })
  }
<<<<<<< HEAD
  static indexReference(i: number) {
=======

  static indexReference(i: number): Expression {
>>>>>>> origin/main
    return new Expression({
      type: 'index',
      value: i,
    })
  }
}

// Tests an operator on two given primitive values
<<<<<<< HEAD
function testBinaryOperator(lhsValue, operator, rhsValue) {
=======
function testBinaryOperator(lhsValue: any, operator: string, rhsValue: any) {
>>>>>>> origin/main
  switch (operator) {
    case '>':
      return lhsValue > rhsValue
    case '>=':
      return lhsValue >= rhsValue
    case '<':
      return lhsValue < rhsValue
    case '<=':
      return lhsValue <= rhsValue
    case '==':
      return lhsValue === rhsValue
    case '!=':
<<<<<<< HEAD
      return lhsValue != rhsValue
=======
      return lhsValue !== rhsValue
>>>>>>> origin/main
    default:
      throw new Error(`Unsupported binary operator ${operator}`)
  }
}
<<<<<<< HEAD
function interpretNegativeIndex(index: number, probe: Probe) {
  if (index < 0) {
    return index + probe.length()
  }
  return index
=======

function interpretNegativeIndex(index: number, probe?: Probe): number {
  if (index >= 0) {
    return index
  }

  if (!probe) {
    throw new Error('interpretNegativeIndex() must have a probe when < 0')
  }

  return index + probe.length()
>>>>>>> origin/main
}
