<<<<<<< HEAD
// Descender models the state of one partial jsonpath evaluation. Head is the
// next thing to match, tail is the upcoming things once the head is matched.

import {flatten} from 'lodash'
import Expression from './Expression'

export type Probe = {
  containerType(): string
  length(): number
  getIndex(index: number): any
  get: () => any
  getAttribute(string): any
  attributeKeys(): string[]
  hasAttribute(attr: string): boolean
}

export default class Descender {
  head: Expression
  tail: Expression
  constructor(head: Expression, tail: Expression) {
    this.head = head
    this.tail = tail
  }
  // Iterate this descender once processing any constraints that are
  // resolvable on the current value. Returns an array of new descenders
  // that are guaranteed to be without constraints in the head
  iterate(probe: Probe): Array<Descender> {
    let result: Array<Descender> = [this]
=======
import {flatten} from 'lodash'

import {Expression} from './Expression'
import {type Probe} from './Probe'

/**
 * Descender models the state of one partial jsonpath evaluation. Head is the
 * next thing to match, tail is the upcoming things once the head is matched.
 */
export class Descender {
  head: Expression | null
  tail: Expression | null

  constructor(head: Expression | null, tail: Expression | null) {
    this.head = head
    this.tail = tail
  }

  // Iterate this descender once processing any constraints that are
  // resolvable on the current value. Returns an array of new descenders
  // that are guaranteed to be without constraints in the head
  iterate(probe: Probe): Descender[] {
    let result: Descender[] = [this]
>>>>>>> origin/main
    if (this.head && this.head.isConstraint()) {
      let anyConstraints = true
      // Keep rewriting constraints until there are none left
      while (anyConstraints) {
        result = flatten(
          result.map((descender) => {
            return descender.iterateConstraints(probe)
<<<<<<< HEAD
          })
=======
          }),
>>>>>>> origin/main
        )
        anyConstraints = result.some((descender) => {
          return descender.head && descender.head.isConstraint()
        })
      }
    }
    return result
  }

  isRecursive(): boolean {
<<<<<<< HEAD
    return this.head && this.head.isRecursive()
=======
    return Boolean(this.head && this.head.isRecursive())
>>>>>>> origin/main
  }

  hasArrived(): boolean {
    return this.head === null && this.tail === null
  }

<<<<<<< HEAD
  extractRecursives(): Array<Descender> {
    if (this.head.isRecursive()) {
=======
  extractRecursives(): Descender[] {
    if (this.head && this.head.isRecursive()) {
>>>>>>> origin/main
      const term = this.head.unwrapRecursive()
      return new Descender(null, term.concat(this.tail)).descend()
    }
    return []
  }
<<<<<<< HEAD
  iterateConstraints(probe: Probe): Array<Descender> {
=======

  iterateConstraints(probe: Probe): Descender[] {
>>>>>>> origin/main
    const head = this.head
    if (head === null || !head.isConstraint()) {
      // Not a constraint, no rewrite
      return [this]
    }

<<<<<<< HEAD
    const result: Array<Descender> = []
=======
    const result: Descender[] = []
>>>>>>> origin/main

    if (probe.containerType() === 'primitive' && head.constraintTargetIsSelf()) {
      if (head.testConstraint(probe)) {
        result.push(...this.descend())
      }
      return result
    }

    // The value is an array
    if (probe.containerType() === 'array') {
      const length = probe.length()
      for (let i = 0; i < length; i++) {
        // Push new descenders with constraint translated to literal indices
        // where they match
<<<<<<< HEAD
        if (head.testConstraint(probe.getIndex(i))) {
=======
        const constraint = probe.getIndex(i)
        if (constraint && head.testConstraint(constraint)) {
>>>>>>> origin/main
          result.push(new Descender(new Expression({type: 'index', value: i}), this.tail))
        }
      }
      return result
    }

    // The value is an object
<<<<<<< HEAD
    if (probe.containerType() == 'object') {
      if (this.head.constraintTargetIsSelf()) {
        // There are no matches for target self ('@') on a plain object
        return []
      }
      if (this.head.testConstraint(probe)) {
        return this.descend()
      }
=======
    if (probe.containerType() === 'object') {
      if (head.constraintTargetIsSelf()) {
        // There are no matches for target self ('@') on a plain object
        return []
      }

      if (head.testConstraint(probe)) {
        return this.descend()
      }

>>>>>>> origin/main
      return result
    }

    return result
  }
<<<<<<< HEAD
  descend(): Array<Descender> {
    if (!this.tail) {
      return [new Descender(null, null)]
    }
=======

  descend(): Descender[] {
    if (!this.tail) {
      return [new Descender(null, null)]
    }

>>>>>>> origin/main
    return this.tail.descend().map((ht) => {
      return new Descender(ht.head, ht.tail)
    })
  }
<<<<<<< HEAD
=======

>>>>>>> origin/main
  toString(): string {
    const result = ['<']
    if (this.head) {
      result.push(this.head.toString())
    }
    result.push('|')
    if (this.tail) {
      result.push(this.tail.toString())
    }
    result.push('>')
    return result.join('')
  }
}
